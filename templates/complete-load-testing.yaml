AWSTemplateFormatVersion: '2010-09-09'
Description: Complete AWS Distributed Load Testing Solution with actual execution

Parameters:
  AdminEmail:
    Type: String
    Description: Email address for admin notifications
    AllowedPattern: ^[^\s@]+@[^\s@]+\.[^\s@]+$

Resources:
  # S3 Bucket for results
  ResultsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "load-test-results-${AWS::AccountId}-${AWS::Region}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # DynamoDB tables
  TestConfigTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-test-configs"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: testId
          AttributeType: S
      KeySchema:
        - AttributeName: testId
          KeyType: HASH

  TestResultsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-test-results"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: testId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: testId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE

  # VPC and networking
  TestVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true

  TestSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref TestVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']

  TestIGW:
    Type: AWS::EC2::InternetGateway

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref TestVPC
      InternetGatewayId: !Ref TestIGW

  TestRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref TestVPC

  TestRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref TestRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref TestIGW

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref TestSubnet
      RouteTableId: !Ref TestRouteTable

  # Security Group
  TestEngineSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for load test engines
      VpcId: !Ref TestVPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # IAM Roles
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LoadTestingPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                Resource:
                  - !GetAtt TestConfigTable.Arn
                  - !GetAtt TestResultsTable.Arn
              - Effect: Allow
                Action:
                  - s3:*
                Resource:
                  - !Sub "arn:aws:s3:::${ResultsBucket}/*"
                  - !Sub "arn:aws:s3:::${ResultsBucket}"
              - Effect: Allow
                Action:
                  - ec2:*
                  - iam:PassRole
                Resource: "*"

  TestEngineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: TestEnginePermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt TestResultsTable.Arn
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub "arn:aws:s3:::${ResultsBucket}/*"

  TestEngineInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref TestEngineRole

  # Lambda function
  LoadTestManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-load-test-manager"
      Runtime: python3.9
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      Environment:
        Variables:
          CONFIG_TABLE: !Ref TestConfigTable
          RESULTS_TABLE: !Ref TestResultsTable
          RESULTS_BUCKET: !Ref ResultsBucket
          TEST_REGIONS: "us-east-1,us-west-2"
          SUBNET_ID: !Ref TestSubnet
          SECURITY_GROUP_ID: !Ref TestEngineSecurityGroup
          INSTANCE_PROFILE: !GetAtt TestEngineInstanceProfile.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          from datetime import datetime
          import base64
          
          def handler(event, context):
              try:
                  # Handle API Gateway proxy integration
                  if 'body' in event:
                      if event['body']:
                          body = json.loads(event['body'])
                      else:
                          body = {}
                  else:
                      body = event
                  
                  action = body.get('action', 'list')
                  
                  if action == 'create':
                      return create_test(body)
                  elif action == 'start':
                      return start_test(body)
                  elif action == 'stop':
                      return stop_test(body)
                  elif action == 'status':
                      return get_test_status(body)
                  elif action == 'results':
                      return get_test_results(body)
                  elif action == 'list':
                      return list_tests()
                  else:
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Load Test Manager',
                              'actions': ['create', 'start', 'stop', 'status', 'results', 'list']
                          })
                      }
                      
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
          
          def create_test(event):
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              test_id = str(uuid.uuid4())
              regions = event.get('regions', os.environ.get('TEST_REGIONS', 'us-east-1').split(','))
              
              config = {
                  'testId': test_id,
                  'name': event.get('name', 'Load Test'),
                  'target_url': event.get('target_url'),
                  'concurrent_users': int(event.get('concurrent_users', 10)),
                  'duration': int(event.get('duration', 60)),
                  'ramp_up': int(event.get('ramp_up', 10)),
                  'regions': regions,
                  'created_at': datetime.utcnow().isoformat(),
                  'status': 'created'
              }
              
              table.put_item(Item=config)
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'testId': test_id,
                      'message': 'Test configuration created successfully'
                  })
              }
          
          def start_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.get_item(Key={'testId': test_id})
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              config = response['Item']
              ec2 = boto3.client('ec2')
              
              # Ensure URL has proper protocol
              target_url = config['target_url']
              if not target_url.startswith(('http://', 'https://')):
                  target_url = f'https://{target_url}'
              
              user_data = f'''#!/bin/bash
          export AWS_DEFAULT_REGION=us-east-1
          yum update -y
          yum install -y httpd-tools python3 pip
          pip3 install boto3
          
          # Run load test
          ab -c {config['concurrent_users']} -t {config['duration']} "{target_url}" > /tmp/results.txt 2>&1
          
          # Upload results
          python3 << 'EOF'
          import boto3
          import os
          from datetime import datetime
          
          os.environ['AWS_DEFAULT_REGION'] = 'us-east-1'
          
          try:
              with open('/tmp/results.txt', 'r') as f:
                  results = f.read()
              
              dynamodb = boto3.resource('dynamodb', region_name='us-east-1')
              table = dynamodb.Table('{os.environ["RESULTS_TABLE"]}')
              
              table.put_item(Item={{
                  'testId': '{test_id}',
                  'timestamp': datetime.utcnow().isoformat(),
                  'results': results,
                  'region': 'us-east-1'
              }})
          except Exception as e:
              print(f"Error: {e}")
          EOF
          
          shutdown -h +2
          '''
              
              try:
                  response = ec2.run_instances(
                      ImageId='ami-0c02fb55956c7d316',
                      MinCount=1,
                      MaxCount=1,
                      InstanceType='t3.micro',
                      IamInstanceProfile={'Arn': os.environ['INSTANCE_PROFILE']},
                      SubnetId=os.environ['SUBNET_ID'],
                      SecurityGroupIds=[os.environ['SECURITY_GROUP_ID']],
                      UserData=user_data,
                      TagSpecifications=[{
                          'ResourceType': 'instance',
                          'Tags': [
                              {'Key': 'Name', 'Value': f'LoadTest-{test_id[:8]}'},
                              {'Key': 'TestId', 'Value': test_id}
                          ]
                      }]
                  )
                  
                  config_table.update_item(
                      Key={'testId': test_id},
                      UpdateExpression='SET #status = :status, started_at = :started_at, instance_id = :instance_id',
                      ExpressionAttributeNames={'#status': 'status'},
                      ExpressionAttributeValues={
                          ':status': 'running',
                          ':started_at': datetime.utcnow().isoformat(),
                          ':instance_id': response['Instances'][0]['InstanceId']
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Test started successfully, EC2 instance launched',
                          'instance_id': response['Instances'][0]['InstanceId']
                      })
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Failed to launch instance: {str(e)}'})
                  }
          
          def stop_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, stopped_at = :stopped_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'stopped',
                      ':stopped_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test stopped successfully'})
              }
          
          def get_test_status(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.get_item(Key={'testId': test_id})
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Item'], default=str)
              }
          
          def get_test_results(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              results_table = dynamodb.Table(os.environ['RESULTS_TABLE'])
              
              try:
                  response = results_table.query(
                      KeyConditionExpression='testId = :testId',
                      ExpressionAttributeValues={':testId': test_id}
                  )
              except Exception:
                  response = {'Items': []}
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'results': response.get('Items', [])}, default=str)
              }
          
          def list_tests():
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.scan()
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'tests': response.get('Items', [])}, default=str)
              }

  # API Gateway
  LoadTestAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      Description: Load Testing API

  APIResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref LoadTestAPI
      ParentId: !GetAtt LoadTestAPI.RootResourceId
      PathPart: test

  APIMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref LoadTestAPI
      ResourceId: !Ref APIResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LoadTestManagerFunction.Arn}/invocations"

  APIDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: APIMethod
    Properties:
      RestApiId: !Ref LoadTestAPI
      StageName: prod

  APILambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LoadTestManagerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${LoadTestAPI}/*/*"

Outputs:
  APIEndpoint:
    Description: API Gateway endpoint for load testing
    Value: !Sub "https://${LoadTestAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/test"
    
  Instructions:
    Description: How to use the load testing solution
    Value: !Sub |
      API Usage:
      1. Create: POST {"action":"create","target_url":"https://httpbin.org/get","concurrent_users":10,"duration":60}
      2. Start: POST {"action":"start","testId":"your-test-id"}
      3. Status: POST {"action":"status","testId":"your-test-id"}
      4. Results: POST {"action":"results","testId":"your-test-id"}
      5. List: POST {"action":"list"}