AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AWS Distributed Load Testing Solution
  Deploys a complete load testing infrastructure that can simulate traffic
  from multiple AWS regions to test your WordPress site performance.
  This is completely isolated and only sends HTTP requests to your target.

Parameters:
  AdminEmail:
    Type: String
    Description: Email address for admin notifications and login credentials
    AllowedPattern: ^[^\s@]+@[^\s@]+\.[^\s@]+$
    ConstraintDescription: Must be a valid email address

  AdminName:
    Type: String
    Default: admin
    Description: Admin username for the load testing console
    MinLength: 4
    MaxLength: 20

  TestRegions:
    Type: CommaDelimitedList
    Default: "us-east-1,us-west-2,eu-west-1"
    Description: AWS regions to launch test engines from (comma-separated)

  SourceCodeBucket:
    Type: String
    Default: solutions-reference
    Description: S3 bucket containing the solution source code

  SourceCodePrefix:
    Type: String
    Default: distributed-load-testing-on-aws/v3.2.0
    Description: S3 key prefix for the solution source code

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Administrator Configuration"
        Parameters:
          - AdminEmail
          - AdminName
      - Label:
          default: "Load Testing Configuration"
        Parameters:
          - TestRegions
      - Label:
          default: "Solution Configuration"
        Parameters:
          - SourceCodeBucket
          - SourceCodePrefix

Resources:
  # S3 Bucket for storing test results and configurations
  ResultsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "load-test-results-${AWS::AccountId}-${AWS::Region}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldResults
            Status: Enabled
            ExpirationInDays: 30

  # DynamoDB table for storing test configurations and results
  TestConfigTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-test-configs"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: testId
          AttributeType: S
      KeySchema:
        - AttributeName: testId
          KeyType: HASH
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES

  # DynamoDB table for storing test results
  TestResultsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-test-results"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: testId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: testId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE

  # IAM Role for Lambda functions
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LoadTestingPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TestConfigTable.Arn
                  - !GetAtt TestResultsTable.Arn
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub "arn:aws:s3:::${ResultsBucket}/*"
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub "arn:aws:s3:::${ResultsBucket}"
              - Effect: Allow
                Action:
                  - ec2:DescribeRegions
                  - ec2:DescribeInstances
                  - ec2:RunInstances
                  - ec2:TerminateInstances
                  - ec2:CreateTags
                  - iam:PassRole
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  # IAM Role for EC2 test engines
  TestEngineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: TestEnginePermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - !Sub "arn:aws:s3:::${ResultsBucket}/*"
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt TestResultsTable.Arn
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: "*"

  TestEngineInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref TestEngineRole

  # Lambda function for managing load tests
  LoadTestManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-load-test-manager"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      Environment:
        Variables:
          CONFIG_TABLE: !Ref TestConfigTable
          RESULTS_TABLE: !Ref TestResultsTable
          RESULTS_BUCKET: !Ref ResultsBucket
          TEST_REGIONS: !Join [",", !Ref TestRegions]
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          from datetime import datetime
          
          def lambda_handler(event, context):
              try:
                  action = event.get('action', 'list')
                  
                  if action == 'create':
                      return create_test(event)
                  elif action == 'start':
                      return start_test(event)
                  elif action == 'stop':
                      return stop_test(event)
                  elif action == 'status':
                      return get_test_status(event)
                  elif action == 'results':
                      return get_test_results(event)
                  else:
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Load Test Manager',
                              'actions': ['create', 'start', 'stop', 'status', 'results']
                          })
                      }
                      
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
          
          def create_test(event):
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              test_id = str(uuid.uuid4())
              config = {
                  'testId': test_id,
                  'name': event.get('name', 'Load Test'),
                  'target_url': event.get('target_url'),
                  'concurrent_users': event.get('concurrent_users', 100),
                  'duration': event.get('duration', 300),
                  'ramp_up': event.get('ramp_up', 60),
                  'regions': event.get('regions', os.environ['TEST_REGIONS'].split(',')),
                  'created_at': datetime.utcnow().isoformat(),
                  'status': 'created'
              }
              
              table.put_item(Item=config)
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'testId': test_id,
                      'message': 'Test configuration created successfully'
                  })
              }
          
          def start_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, started_at = :started_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'running',
                      ':started_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test started successfully'})
              }
          
          def stop_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, stopped_at = :stopped_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'stopped',
                      ':stopped_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test stopped successfully'})
              }
          
          def get_test_status(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.get_item(Key={'testId': test_id})
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Item'], default=str)
              }
          
          def get_test_results(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              results_table = dynamodb.Table(os.environ['RESULTS_TABLE'])
              
              response = results_table.query(
                  KeyConditionExpression='testId = :testId',
                  ExpressionAttributeValues={':testId': test_id}
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'results': response.get('Items', [])})
              }
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, started_at = :started_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'running',
                      ':started_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test started successfully'})
              }
          
          def stop_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, stopped_at = :stopped_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'stopped',
                      ':stopped_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test stopped successfully'})
              }
          
          def get_test_status(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.get_item(Key={'testId': test_id})
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Item'], default=str)
              }
          
          def get_test_results(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              results_table = dynamodb.Table(os.environ['RESULTS_TABLE'])
              
              response = results_table.query(
                  KeyConditionExpression='testId = :testId',
                  ExpressionAttributeValues={':testId': test_id}
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'results': response.get('Items', [])})
              }
          
          def list_tests():
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.scan()
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'tests': response.get('Items', [])})
              }

  # VPC for test engines
  TestVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpc"

  TestSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref TestVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-subnet"

  TestIGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-igw"

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref TestVPC
      InternetGatewayId: !Ref TestIGW

  TestRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref TestVPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-rt"

  TestRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref TestRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref TestIGW

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref TestSubnet
      RouteTableId: !Ref TestRouteTable

  # Security Group
  TestEngineSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for load test engines
      VpcId: !Ref TestVPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-sg"

  # Launch Template for Test Engines
  TestEngineLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub "${AWS::StackName}-test-engine"
      LaunchTemplateData:
        ImageId: ami-0c02fb55956c7d316
        InstanceType: t3.medium
        IamInstanceProfile:
          Arn: !GetAtt TestEngineInstanceProfile.Arn
        SecurityGroupIds:
          - !Ref TestEngineSecurityGroup
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            yum update -y
            yum install -y httpd-tools python3 pip
            pip3 install boto3 requests
            
            cat > /home/ec2-user/load_test.py << 'EOF'
            #!/usr/bin/env python3
            import boto3
            import subprocess
            import json
            import time
            from datetime import datetime
            
            def run_load_test(url, concurrent, duration):
                cmd = ['ab', '-c', str(concurrent), '-t', str(duration), url]
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=duration+60)
                    return {'stdout': result.stdout, 'stderr': result.stderr, 'returncode': result.returncode}
                except Exception as e:
                    return {'error': str(e)}
            
            def upload_results(test_id, results):
                dynamodb = boto3.resource('dynamodb')
                table = dynamodb.Table('${TestResultsTable}')
                table.put_item(Item={
                    'testId': test_id,
                    'timestamp': datetime.utcnow().isoformat(),
                    'results': json.dumps(results),
                    'region': boto3.Session().region_name
                })
            
            def main():
                dynamodb = boto3.resource('dynamodb')
                table = dynamodb.Table('${TestConfigTable}')
                
                while True:
                    try:
                        response = table.scan(
                            FilterExpression='#status = :status',
                            ExpressionAttributeNames={'#status': 'status'},
                            ExpressionAttributeValues={':status': 'running'}
                        )
                        if response['Items']:
                            config = response['Items'][0]
                            break
                    except:
                        pass
                    time.sleep(10)
                
                results = run_load_test(config['target_url'], config['concurrent_users'], config['duration'])
                upload_results(config['testId'], results)
                subprocess.run(['sudo', 'shutdown', '-h', '+5'])
            
            if __name__ == '__main__':
                main()
            EOF
            
            chmod +x /home/ec2-user/load_test.py
            nohup python3 /home/ec2-user/load_test.py > /var/log/load_test.log 2>&1 &

  # API Gateway
  LoadTestAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      Description: Load Testing API

  APIResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref LoadTestAPI
      ParentId: !GetAtt LoadTestAPI.RootResourceId
      PathPart: test

  APIMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref LoadTestAPI
      ResourceId: !Ref APIResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LoadTestManagerFunction.Arn}/invocations"

  APIDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: APIMethod
    Properties:
      RestApiId: !Ref LoadTestAPI
      StageName: prod

  APILambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LoadTestManagerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${LoadTestAPI}/*/*"

  # SNS for notifications
  NotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub "${AWS::StackName}-notifications"

  NotificationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref NotificationTopic
      Protocol: email
      Endpoint: !Ref AdminEmail

Outputs:
  APIEndpoint:
    Description: API Gateway endpoint for load testing
    Value: !Sub "https://${LoadTestAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/test"
    
  LambdaFunction:
    Description: Lambda function name for direct testing
    Value: !Ref LoadTestManagerFunction
    
  ConfigTable:
    Description: DynamoDB config table
    Value: !Ref TestConfigTable
    
  ResultsTable:
    Description: DynamoDB results table
    Value: !Ref TestResultsTable
    
  Instructions:
    Description: How to use the load testing solution
    Value: !Sub |
      API Usage:
      1. Create: POST {"action":"create","target_url":"https://atl.direct","concurrent_users":100,"duration":300}
      2. Start: POST {"action":"start","testId":"your-test-id"}
      3. Status: POST {"action":"status","testId":"your-test-id"}
      4. Results: POST {"action":"results","testId":"your-test-id"}
      5. Stop: POST {"action":"stop","testId":"your-test-id"}
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              # Update test status to running
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, started_at = :started_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'running',
                      ':started_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test started successfully'})
              }
          
          def stop_test(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              config_table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, stopped_at = :stopped_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'stopped',
                      ':stopped_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test stopped successfully'})
              }
          
          def get_test_status(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.get_item(Key={'testId': test_id})
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Item'])
              }
          
          def get_test_results(event):
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              results_table = dynamodb.Table(os.environ['RESULTS_TABLE'])
              
              response = results_table.query(
                  KeyConditionExpression='testId = :testId',
                  ExpressionAttributeValues={':testId': test_id}
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'results': response.get('Items', [])})
              }
          
          def list_tests():
              dynamodb = boto3.resource('dynamodb')
              config_table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = config_table.scan()
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'tests': response.get('Items', [])})
              }
          
          def start_test(event):
              """Start a load test"""
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId is required'})
                  }
              
              # Update test status to running
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, started_at = :started_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'running',
                      ':started_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test started successfully'})
              }
          
          def stop_test(event):
              """Stop a running load test"""
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId is required'})
                  }
              
              # Update test status to stopped
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              table.update_item(
                  Key={'testId': test_id},
                  UpdateExpression='SET #status = :status, stopped_at = :stopped_at',
                  ExpressionAttributeNames={'#status': 'status'},
                  ExpressionAttributeValues={
                      ':status': 'stopped',
                      ':stopped_at': datetime.utcnow().isoformat()
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({'message': 'Test stopped successfully'})
              }
          
          def get_test_status(event):
              """Get status of a load test"""
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId is required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = table.get_item(Key={'testId': test_id})
              
              if 'Item' not in response:
                  return {
                      'statusCode': 404,
                      'body': json.dumps({'error': 'Test not found'})
                  }
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Item'], default=str)
              }
          
          def get_test_results(event):
              """Get results of a load test"""
              test_id = event.get('testId')
              if not test_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'testId is required'})
                  }
              
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['RESULTS_TABLE'])
              
              response = table.query(
                  KeyConditionExpression='testId = :testId',
                  ExpressionAttributeValues={':testId': test_id}
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Items'], default=str)
              }
          
          def list_tests():
              """List all load tests"""
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table(os.environ['CONFIG_TABLE'])
              
              response = table.scan()
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(response['Items'], default=str)
              }

  # API Gateway for the web console
  LoadTestingAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-load-testing-api"
      Description: API for distributed load testing console
      EndpointConfiguration:
        Types:
          - REGIONAL

  # API Gateway Lambda Integration
  APILambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LoadTestManagerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${LoadTestingAPI}/*/*"

  # CloudWatch Dashboard for monitoring
  LoadTestingDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub "${AWS::StackName}-load-testing"
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/Lambda", "Duration", "FunctionName", "${LoadTestManagerFunction}" ],
                  [ ".", "Errors", ".", "." ],
                  [ ".", "Invocations", ".", "." ]
                ],
                "period": 300,
                "stat": "Average",
                "region": "${AWS::Region}",
                "title": "Load Testing Manager Metrics"
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 6,
              "width": 24,
              "height": 6,
              "properties": {
                "query": "SOURCE '/aws/lambda/${LoadTestManagerFunction}'\n| fields @timestamp, @message\n| sort @timestamp desc\n| limit 100",
                "region": "${AWS::Region}",
                "title": "Load Testing Logs"
              }
            }
          ]
        }

  # SNS Topic for notifications
  NotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub "${AWS::StackName}-notifications"

  # SNS Subscription for admin email
  NotificationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref NotificationTopic
      Protocol: email
      Endpoint: !Ref AdminEmail

Outputs:
  LoadTestingAPIEndpoint:
    Description: API Gateway endpoint for load testing console
    Value: !Sub "https://${LoadTestingAPI}.execute-api.${AWS::Region}.amazonaws.com/prod"
    Export:
      Name: !Sub "${AWS::StackName}-api-endpoint"

  ResultsBucketName:
    Description: S3 bucket for storing test results
    Value: !Ref ResultsBucket
    Export:
      Name: !Sub "${AWS::StackName}-results-bucket"

  ConfigTableName:
    Description: DynamoDB table for test configurations
    Value: !Ref TestConfigTable
    Export:
      Name: !Sub "${AWS::StackName}-config-table"

  ResultsTableName:
    Description: DynamoDB table for test results
    Value: !Ref TestResultsTable
    Export:
      Name: !Sub "${AWS::StackName}-results-table"

  DashboardURL:
    Description: CloudWatch dashboard for monitoring load tests
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${AWS::StackName}-load-testing"

  TestRegions:
    Description: AWS regions configured for load testing
    Value: !Join [", ", !Ref TestRegions]

  AdminInstructions:
    Description: Instructions for using the load testing solution
    Value: !Sub 
      - |
        1. Deploy this stack and wait for completion
        2. Check your email (${AdminEmail}) for login credentials
        3. Access the API endpoint to manage load tests
        4. Configure test targeting: https://atl.direct
        5. Monitor results in CloudWatch dashboard
        6. Test engines will be launched in: ${RegionList}
      - RegionList: !Join [", ", !Ref TestRegions]